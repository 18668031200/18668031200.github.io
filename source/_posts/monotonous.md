---
title: monotonous
author: ygdxd
type: 转载
date: 2019-05-06 20:49:57
tags: 算法
---

单调栈结构
============================


问题
--------------------------------------------------

给定一个不含有重复值的数组arr,找到每一个i位置左边和右边离i位置最近且值比arr[i]小的位置，返回所有位置相应的信息。
时间复杂度 O（N）。
<!-- more -->

举例
--------------------------------------------------

arr = [3,4,1,5,6,2,7]

返回数组 [[-1,2],[0,2],[-1,-1],[2,5],[3,5],[2,-1],[5,-1]] -1表示不存在。



解答
--------------------------------------------------

准备一个栈 stack<integer>, 栈中存放数组中的元素，初始化stack为空。如果要求找到每一个i位置左边和右边离i位置最近且值比arr[i]小的位置，就么就需要然stack从栈顶到栈底的位置所代表的元素值必须是严格递减的，反之亦然。这里是递减。


初始化arr = [3,4,1,5,6,2,7],stack = {}.

遍历到arr[0] == 3, i == 0,发现stack为空，将 位置0 入栈 ,stack变为 {0(3)}. 

遍历到arr[1] == 4, 发现将 1（4）放入stack不会破坏stack从栈顶到栈底严格递减，直接放入. stack变为 {1(4),0(3)}

遍历到arr[2] == 1, i == 2 发现将 2（1）放入stack会破坏严格递减的规则，所以从stack的栈顶开始弹出元素。如果x位置被弹出，在栈中位于x位置下面的位置就是左边离x位置最近且比arr[x]小的位置，i 就是x位置右边离x位置最近且比arr[x]小的位置。所以ans[1] = [0, 2].弹出x(1)后发现放入位置2（1）还是会破坏严格递减的规则，所以弹出0（3），因为stack在0（3）下面没有元素了，说明在位置0（3）左边没有存在比它还小的元素，所以ans[0] = [-1, 2].此时stack 为空，将2（1）压入stack.

遍历到arr[3] == 5 ,发现arr[3] > arr[2], 直接放入3（5）， stack依次为{3(5), 2(1)}

遍历到arr[4] == 6 ,同上放入， stack依次为{4(6), 3(5), 2(1)}

遍历到arr[5] == 2, 因为放入会破坏单调递减， 依次弹出4(6), 3(5)， 位置4下面是3，所以ans[4] = {3,5},位置3下面是位置2， 所以ans[3] = {2,5}. 最后放入5(2)， stack依次为{5(2), 2(1)}

遍历到 arr[6] == 7, 直接放入stack ，stack依次为{6(7), 5(2), 2(1)}

遍历阶段结束后，清算栈中剩下的位置。因为是清算过程中，所以数组中不存在在右边比它们小的元素，所以ans[x] = {?, -1}

弹出位置6， 栈中它下面的位置是5(2), 所以ans[6] = {5, -1}
弹出位置5， 栈中它下面的位置是2(1), 所以ans[6] = {2, -1}
最后只剩下2(1)，因为栈中已经没有元素了，所以ans[2] = {-1,-1} 
至此全部完成，整个流程中，每个位置都进栈一次，出栈一次，所以整个流程的时间复杂度为O（N）



重复问题
--------------------------------------------------

当数组中的元素允许重复时，元素（位置）入栈时不变，如果值相同则将位置替换。


代码
--------------------------------------------------

{% codeblock solution.java lang:java %}

public int[][] getNearLessNoRepeat(int[] arr){
        int[][] res = new int[arr.length][2];
        Stack<Integer> stack = new Stack<>();
        for (int i = 0; i < arr.length; i++) {
            while (!stack.empty() && arr[stack.peek()] > arr[i]){
                int a = stack.pop();
                int left = stack.isEmpty() ? -1 : stack.peek();
                res[a][0] = left;
                res[a][1] = i;
            }
            stack.push(i);
        }
        //遍历完
        while (!stack.isEmpty()){
            int a = stack.pop();
            int left = stack.isEmpty() ? -1 : stack.peek();
            res[a][0] = left;
            res[a][1] = -1;
        }
        return res;

    }
    
{% endcodeblock %}



来源
--------------------------------------------------

左程云 《程序员算法面试指南》
