{"pages":[],"posts":[{"title":"spring security 1 配置类加载","text":"##spring security 配置类加载 ####WebSecurityConfigurerAdapter 一般我们在使用spring security作为我们安全验证的时候经常会编写配置类继承WebSecurityConfigurerAdapter，通过重写其中的config()类来自定义自己的安全验证流程。而HttpSecurity类则是其中非常重要的一个配置类，通过它你可以集成其他第三方的生态来满足自己的业务需求。 ####HttpSecurity 在HttpSecurity 中我们可以看到很多配置方法比如 HttpSecurit.java1234567891011public OpenIDLoginConfigurer&lt;HttpSecurity&gt; openidLogin() throws Exception { return getOrApply(new OpenIDLoginConfigurer&lt;&gt;()); } ...public HeadersConfigurer&lt;HttpSecurity&gt; headers() throws Exception { return getOrApply(new HeadersConfigurer&lt;&gt;()); } 很明显它们都调用了getOrAppley方法 HttpSecurit.java123456789101112private &lt;C extends SecurityConfigurerAdapter&lt;DefaultSecurityFilterChain, HttpSecurity&gt;&gt; C getOrApply( C configurer) throws Exception { //从已加载中的配置类根据class获取 C existingConfig = (C) getConfigurer(configurer.getClass()); //不为空的或就返回已加载类 if (existingConfig != null) { return existingConfig; } return apply(configurer); } 再看apply这个方法 AbstractConfiguredSecurityBuilder123456789101112public &lt;C extends SecurityConfigurerAdapter&lt;O, B&gt;&gt; C apply(C configurer) throws Exception { //添加后置处理器 configurer.addObjectPostProcessor(objectPostProcessor); //设置builder configurer.setBuilder((B) this); //把这个配置类添加到配置类集合中 add(configurer); return configurer; } 首先objectPostProcessor 应该是ObjectPostProcessorConfiguration这个配置类中的AutowireBeanFactoryObjectPostProcessor实例，它管理了一系列的SmartInitializingSingleton的afterSingletonsInstantiated方法和DisposableBean的destroy方法，以确保他们被调用。 configurer.setBuilder((B) this); 则是把builder类的引用放到配置类中（SecurityConfigurerAdapter子类）这样配置类就可以通过getbuilder()方法来实现一系列操作。 最后configer会被放入一个集合中通过doBuild()方法来进行加载初始化 AbstractConfiguredSecurityBuilder1234567891011121314151617181920212223242526protected final O doBuild() throws Exception { //加锁 synchronized (configurers) { buildState = BuildState.INITIALIZING; beforeInit(); init(); buildState = BuildState.CONFIGURING; beforeConfigure(); configure(); buildState = BuildState.BUILDING; O result = performBuild(); buildState = BuildState.BUILT; return result; } } 各种配置类有各自的实现，这样ss就可以扩展安全验证的机制了。","link":"/2019/04/22/ss-config1/"},{"title":"LINUX I/O 简介","text":"LINUX I/O 简介在linux中所有外部设备，进程，网络都可以看成一个文件来操作，对一个文件的读写操作会调用内核提供的系统命令，返回一个file descriptor(fd,文件描述符)。对一个socket的读写也会有相应的描述符，称为socketfd(socket描述符)，描述符就是一个数字，它指向内核中的一个结构体（文件路径，数据区等一些属性）。 ####基本I/O与标准I/O 类unix系统中有直接对文件进行的操作函数read()/write()，这些被称为不带缓冲的I/O；标准I/O在基本的I/O函数基础上增加了流和缓冲的概念，常用的函数有fopen/getc()/putc()等，标准I/O使用了缓冲的机制，缓冲又分为全缓冲和行缓冲，引入缓冲机制主要是为了提供文件读写的性能和效率。 读文件调用getc()时,操作系统底层会使用read()函数，并从用户空间切换到内核空间，执行系统调用。首先将文件页从磁盘拷贝到页缓存中，由于页缓存处在内核空间，不能被用户进程直接寻址，所以还需要将页缓存中数据页再次拷贝到内存对应的用户空间中。这样，经过两次数据拷贝过程，进程才能获取到文件内容。写操作也是一样，用户态写数据时，待发送数据所在的缓冲区处于内核空间，用户态不能直接访问，必须先拷贝至内核空间对应的主存，才能写回磁盘中（延迟写回），因此写入也是需要两次数据拷贝。 ####I/O模型 I/O阻塞模型 默认情况下，我们使用的都是阻塞I/O模型，在缺省情况下所有对文件的操作都是阻塞的。以套接字为例，在进程空间中调用recvfrom. If no messages are available at the socket, the receive calls wait for a message to arrive, unless the socket is nonblocking (see fcntl(2)), in which case the value -1 is returned and the external variable errno is set to EAGAIN or EWOULDBLOCK. 他会去等待信息返回且被复制到应用进程的缓冲区内或者发送错误并且发送到EAGAIN or EWOULDBLOCK. ，进程会在此期间一直等待。 非阻塞I/O模型 非阻塞IO模型下，我们发出open/read/write这样的IO操作时，这些操作不会永远阻塞，而是立即返回。对于一个给定的文件描述符，有两种指定非阻塞的方法： 1.调用open获得描述符时，可指定O_NONBLOCK标志。 2.对于一个已经打开的描述符，可调用fcntl，由该函数打开O_NONBLOCK状态标志。 非阻塞模型由于立即返回，后面需要轮询不断的查看读写是否已经就绪，然后才能进行I/O操作 IO复用 Linux 提供select/poll,进程通过将一个或多个fd传递给select或poll系统调用，阻塞在select操作上，这样select/poll可以帮我们侦测多个fd是否处于就绪状态。缺点：受FD_SETSIZE大小影响，优点：Linux 提供epoll系统调用，epoll使用基于事件驱动方式代替顺序扫描,性能更高。 信号驱动I/O 需要开启套接口信号驱动I/O功能，系统通过调用sigaction执行一个信号处理函数（此系统调用立即返回，非阻塞）。当数据返回时生成一个SIGIO，通过信号回调通知应用系统调用recvfrom读取数据。 异步I/O 告知kernel启动某个操作，并让kernel在完成整个操作后（包括将数据从kernel复制到用户自己的缓存区）进行通知，与信号驱动模型的主要区别是信号驱动I/O有kernel通知何时开始，而异步I/O有kernel通知何时完成。 ####epoll epoll在2.5.44内核中被引进,epoll与select的原理比较相似，主要因为select一些固有的缺陷所有linux使用了epoll来代替select.而除了epoll，在freeBSD下还有kqueue,Solaris的/dev/poll.epoll 在文件描述符可进行 I/O 操作时进行通知，而 kqueue 和 IOCP 都在请求的操作完成时进行通知。 在select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。 ######epoll的优点 支持一个进程打开的socket描述符（fd）不受FD_SETSIZE限制(仅受限与操作系统的最大文件句柄数) I/O效率不会随着FD的数目的增加而线性下降 使用mmap加速内核与用户空间的消息传递（mmap是一种内存映射文件的方法，可以将一个文件或者其它对象映射到进程的虚拟地址空间，实现文件磁盘地址和进程虚拟地址空间中某一段地址的一一对映，这样应用程序就可以通过访问进程虚拟内存地地址直接访问到文件或对象。） epoll的api更加简单 来源netty netty权威指南","link":"/2019/04/18/year-month-day-LinuxIO-md/"},{"title":"icarus-bug","text":"##记一次hexo切换主题icarus排版混乱的bug ######起因 第一次使用hexo搭建blog,看到icarus主题漂亮就入了坑，本地运行完美。仿照国内教程各种详细的配置。 http://blog.kimzing.com/ 准备remote上传 1sudo hexo d -g 一切ok,打开网站却发现左边的介绍去了中间，样式全无。按F12查看控制台发现并没有脚本或者css报错信息，只能google. 搜索内容如下 1.查看css文件完整性 打开F12对比发现完全一下 2.修改根目录下的url 设置完发现无用 ######结果 在下面helloworld中发现了类似图片404的图片，于是就想着先删除它，在本地rm helloworld.md后 12sudo hexo gsudo hexo d hellowold 没删掉 排版好了。。。","link":"/2019/04/18/icarus-bug/"},{"title":"DirectByteBuffer","text":"堆外内存DirectByteBufferDirectByteBuffer是jdk提供的访问对外内存的一种实现，堆外内存的优势在于，1.使用socket网络传输时，它能够节省堆内存到堆外内存的复制消耗。2.对于磁盘io,可以使用内存映射，提高效率。3.不需要考虑gc问题。它并不受jvm内存管理,所有当对外内存不足时，系统会显式地调用一次System.gc()，如果还是不能申请到足够内存，系统就会报出 12java.lang.OutOfMemoryError: Direct buffer memory 如果我们在jvm参数上加上 -XX:+DisableExplicitGC 那么就会使显式gc无效。同时我们也可以通过增大-XX:MaxDirectMemorySize来增加堆外内存 下面看一下DirectByteBuffer的创建DirectByteBuffer.java1234567891011121314151617181920212223242526272829303132333435DirectByteBuffer(int cap) { // package-private super(-1, 0, cap, cap); //是否对齐 boolean pa = VM.isDirectMemoryPageAligned(); //默认每页的大小 int ps = Bits.pageSize(); long size = Math.max(1L, (long)cap + (pa ? ps : 0)); //在申请或者释放内存时都应该调用 里面通过CAS来count //在这个方法中 如果检测到内存不够就会显式调用system.gc() Bits.reserveMemory(size, cap); long base = 0; try { //调用jni申请内存 base = UNSAFE.allocateMemory(size); } catch (OutOfMemoryError x) { //cas 减少数量 Bits.unreserveMemory(size, cap); throw x; } UNSAFE.setMemory(base, size, (byte) 0); if (pa &amp;&amp; (base % ps != 0)) { // Round up to page boundary address = base + ps - (base &amp; (ps - 1)); } else { address = base; } //添加cleaner 用于回收内存 cleaner = Cleaner.create(this, new Deallocator(base, size, cap)); att = null; 在看下Cleaner,它继承了PhantomReference。 PhantomReference的作用在于跟踪垃圾回收过程 Phantom reference objects, which are enqueued after the collector determines that their referents may otherwise be reclaimed. Reference中有个ReferenceHandler 它会一直检测getAndClearReferencePendingList()获得的list, Reference.java1234567891011121314151617181920212223242526272829303132333435363738private static void processPendingReferences() { // Only the singleton reference processing thread calls // waitForReferencePendingList() and getAndClearReferencePendingList(). // These are separate operations to avoid a race with other threads // that are calling waitForReferenceProcessing(). waitForReferencePendingList(); Reference&lt;Object&gt; pendingList; synchronized (processPendingLock) { pendingList = getAndClearReferencePendingList(); processPendingActive = true; } while (pendingList != null) { Reference&lt;Object&gt; ref = pendingList; pendingList = ref.discovered; ref.discovered = null; //这里如果ref是Cleaner 就会调用它的clean()方法 if (ref instanceof Cleaner) { ((Cleaner)ref).clean(); // Notify any waiters that progress has been made. // This improves latency for nio.Bits waiters, which // are the only important ones. synchronized (processPendingLock) { processPendingLock.notifyAll(); } } else { ReferenceQueue&lt;? super Object&gt; q = ref.queue; if (q != ReferenceQueue.NULL) q.enqueue(ref); } } // Notify any waiters of completion of current round. synchronized (processPendingLock) { processPendingActive = false; processPendingLock.notifyAll(); } } 而cleaner会调用Deallocator里面的 DirectByteBuffer.java1234567891011public void run() { if (address == 0) { // Paranoia return; } //释放内存 UNSAFE.freeMemory(address); address = 0; Bits.unreserveMemory(size, capacity); } netty堆外内存AbstractByteBufAllocator protected abstract ByteBuf newDirectBuffer(int initialCapacity, int maxCapacity); 在它的实现里有池化和非池化，这里主要介绍池化策略。 PooledByteBufAllocatorPooledByteBufAllocator采用的是jemalloc来进行内存分配。jemalloc将内存划分为一个个Arena，而在PooledByteBufAllocator里面，程序维护了heapArenas和directArenas，分别代表堆内和堆外Arena。每个Arena又有多个chunk组成。可以看到PoolArena中有PoolChunkList - 存储chunk，SizeClass枚举类 - 对分配内存的大小作区分，tinySubpagePools - 用来保存为tiny规格分配的内存页的链表， smallSubpagePools -用来保存为small规格分配的内存页的链表。 PooledByteBufAllocator.java123456789101112131415161718@Override protected ByteBuf newDirectBuffer(int initialCapacity, int maxCapacity) { PoolThreadCache cache = threadCache.get(); PoolArena&lt;ByteBuffer&gt; directArena = cache.directArena; final ByteBuf buf; if (directArena != null) { //分配内存 buf = directArena.allocate(cache, initialCapacity, maxCapacity); } else { buf = PlatformDependent.hasUnsafe() ? UnsafeByteBufUtil.newUnsafeDirectByteBuf(this, initialCapacity, maxCapacity) : new UnpooledDirectByteBuf(this, initialCapacity, maxCapacity); } return toLeakAwareBuffer(buf); } PoolArena.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768private void allocate(PoolThreadCache cache, PooledByteBuf&lt;T&gt; buf, final int reqCapacity) { //计算大小 final int normCapacity = normalizeCapacity(reqCapacity); //根据大小选择不同的PoolSubpage 和 allocate if (isTinyOrSmall(normCapacity)) { // capacity &lt; pageSize int tableIdx; PoolSubpage&lt;T&gt;[] table; boolean tiny = isTiny(normCapacity); if (tiny) { // &lt; 512 //具体allocate if (cache.allocateTiny(this, buf, reqCapacity, normCapacity)) { // was able to allocate out of the cache so move on return; } //计算出索引 tableIdx = tinyIdx(normCapacity); table = tinySubpagePools; } else { if (cache.allocateSmall(this, buf, reqCapacity, normCapacity)) { // was able to allocate out of the cache so move on return; } tableIdx = smallIdx(normCapacity); table = smallSubpagePools; } //准备放到对应的page数组中 final PoolSubpage&lt;T&gt; head = table[tableIdx]; /** * Synchronize on the head. This is needed as {@link PoolChunk#allocateSubpage(int)} and * {@link PoolChunk#free(long)} may modify the doubly linked list as well. */ synchronized (head) { final PoolSubpage&lt;T&gt; s = head.next; if (s != head) { assert s.doNotDestroy &amp;&amp; s.elemSize == normCapacity; long handle = s.allocate(); assert handle &gt;= 0; s.chunk.initBufWithSubpage(buf, null, handle, reqCapacity); incTinySmallAllocation(tiny); return; } } synchronized (this) { allocateNormal(buf, reqCapacity, normCapacity); } incTinySmallAllocation(tiny); return; } if (normCapacity &lt;= chunkSize) { //在缓存外分配 if (cache.allocateNormal(this, buf, reqCapacity, normCapacity)) { // was able to allocate out of the cache so move on return; } synchronized (this) { allocateNormal(buf, reqCapacity, normCapacity); ++allocationsNormal; } } else { // Huge allocations are never served via the cache so just call allocateHuge allocateHuge(buf, reqCapacity); } } 我们可以看到分配内存的信息会被保存在Aerna的chunk和page对应链表中。同时它会根据请求分配的大小选择不同的chunk和page. 参考堆外内存之 DirectByteBuffer 详解 涤生","link":"/2019/04/28/DirectByteBuffer/"}],"tags":[{"name":"spring security","slug":"spring-security","link":"/tags/spring-security/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"icarus","slug":"icarus","link":"/tags/icarus/"},{"name":"nio","slug":"nio","link":"/tags/nio/"}],"categories":[]}