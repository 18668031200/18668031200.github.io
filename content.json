{"pages":[],"posts":[{"title":"spring security 1 配置类加载","text":"##spring security 配置类加载 ####WebSecurityConfigurerAdapter 一般我们在使用spring security作为我们安全验证的时候经常会编写配置类继承WebSecurityConfigurerAdapter，通过重写其中的config()类来自定义自己的安全验证流程。而HttpSecurity类则是其中非常重要的一个配置类，通过它你可以集成其他第三方的生态来满足自己的业务需求。 ####HttpSecurity 在HttpSecurity 中我们可以看到很多配置方法比如 HttpSecurit.java1234567891011public OpenIDLoginConfigurer&lt;HttpSecurity&gt; openidLogin() throws Exception { return getOrApply(new OpenIDLoginConfigurer&lt;&gt;()); } ...public HeadersConfigurer&lt;HttpSecurity&gt; headers() throws Exception { return getOrApply(new HeadersConfigurer&lt;&gt;()); } 很明显它们都调用了getOrAppley方法 HttpSecurit.java123456789101112private &lt;C extends SecurityConfigurerAdapter&lt;DefaultSecurityFilterChain, HttpSecurity&gt;&gt; C getOrApply( C configurer) throws Exception { //从已加载中的配置类根据class获取 C existingConfig = (C) getConfigurer(configurer.getClass()); //不为空的或就返回已加载类 if (existingConfig != null) { return existingConfig; } return apply(configurer); } 再看apply这个方法 AbstractConfiguredSecurityBuilder123456789101112public &lt;C extends SecurityConfigurerAdapter&lt;O, B&gt;&gt; C apply(C configurer) throws Exception { //添加后置处理器 configurer.addObjectPostProcessor(objectPostProcessor); //设置builder configurer.setBuilder((B) this); //把这个配置类添加到配置类集合中 add(configurer); return configurer; } 首先objectPostProcessor 应该是ObjectPostProcessorConfiguration这个配置类中的AutowireBeanFactoryObjectPostProcessor实例，它管理了一系列的SmartInitializingSingleton的afterSingletonsInstantiated方法和DisposableBean的destroy方法，以确保他们被调用。 configurer.setBuilder((B) this); 则是把builder类的引用放到配置类中（SecurityConfigurerAdapter子类）这样配置类就可以通过getbuilder()方法来实现一系列操作。 最后configer会被放入一个集合中通过doBuild()方法来进行加载初始化 AbstractConfiguredSecurityBuilder1234567891011121314151617181920212223242526protected final O doBuild() throws Exception { //加锁 synchronized (configurers) { buildState = BuildState.INITIALIZING; beforeInit(); init(); buildState = BuildState.CONFIGURING; beforeConfigure(); configure(); buildState = BuildState.BUILDING; O result = performBuild(); buildState = BuildState.BUILT; return result; } } 各种配置类有各自的实现，这样ss就可以扩展安全验证的机制了。","link":"/2019/04/22/ss-config1/"},{"title":"icarus-bug","text":"##记一次hexo切换主题icarus排版混乱的bug ######起因 第一次使用hexo搭建blog,看到icarus主题漂亮就入了坑，本地运行完美。仿照国内教程各种详细的配置。 http://blog.kimzing.com/ 准备remote上传 1sudo hexo d -g 一切ok,打开网站却发现左边的介绍去了中间，样式全无。按F12查看控制台发现并没有脚本或者css报错信息，只能google. 搜索内容如下 1.查看css文件完整性 打开F12对比发现完全一下 2.修改根目录下的url 设置完发现无用 ######结果 在下面helloworld中发现了类似图片404的图片，于是就想着先删除它，在本地rm helloworld.md后 12sudo hexo gsudo hexo d hellowold 没删掉 排版好了。。。","link":"/2019/04/18/icarus-bug/"},{"title":"LINUX I/O 简介","text":"LINUX I/O 简介在linux中所有外部设备，进程，网络都可以看成一个文件来操作，对一个文件的读写操作会调用内核提供的系统命令，返回一个file descriptor(fd,文件描述符)。对一个socket的读写也会有相应的描述符，称为socketfd(socket描述符)，描述符就是一个数字，它指向内核中的一个结构体（文件路径，数据区等一些属性）。 ####基本I/O与标准I/O 类unix系统中有直接对文件进行的操作函数read()/write()，这些被称为不带缓冲的I/O；标准I/O在基本的I/O函数基础上增加了流和缓冲的概念，常用的函数有fopen/getc()/putc()等，标准I/O使用了缓冲的机制，缓冲又分为全缓冲和行缓冲，引入缓冲机制主要是为了提供文件读写的性能和效率。 读文件调用getc()时,操作系统底层会使用read()函数，并从用户空间切换到内核空间，执行系统调用。首先将文件页从磁盘拷贝到页缓存中，由于页缓存处在内核空间，不能被用户进程直接寻址，所以还需要将页缓存中数据页再次拷贝到内存对应的用户空间中。这样，经过两次数据拷贝过程，进程才能获取到文件内容。写操作也是一样，用户态写数据时，待发送数据所在的缓冲区处于内核空间，用户态不能直接访问，必须先拷贝至内核空间对应的主存，才能写回磁盘中（延迟写回），因此写入也是需要两次数据拷贝。 ####I/O模型 I/O阻塞模型 默认情况下，我们使用的都是阻塞I/O模型，在缺省情况下所有对文件的操作都是阻塞的。以套接字为例，在进程空间中调用recvfrom. If no messages are available at the socket, the receive calls wait for a message to arrive, unless the socket is nonblocking (see fcntl(2)), in which case the value -1 is returned and the external variable errno is set to EAGAIN or EWOULDBLOCK. 他会去等待信息返回且被复制到应用进程的缓冲区内或者发送错误并且发送到EAGAIN or EWOULDBLOCK. ，进程会在此期间一直等待。 非阻塞I/O模型 非阻塞IO模型下，我们发出open/read/write这样的IO操作时，这些操作不会永远阻塞，而是立即返回。对于一个给定的文件描述符，有两种指定非阻塞的方法： 1.调用open获得描述符时，可指定O_NONBLOCK标志。 2.对于一个已经打开的描述符，可调用fcntl，由该函数打开O_NONBLOCK状态标志。 非阻塞模型由于立即返回，后面需要轮询不断的查看读写是否已经就绪，然后才能进行I/O操作 IO复用 Linux 提供select/poll,进程通过将一个或多个fd传递给select或poll系统调用，阻塞在select操作上，这样select/poll可以帮我们侦测多个fd是否处于就绪状态。缺点：受FD_SETSIZE大小影响，优点：Linux 提供epoll系统调用，epoll使用基于事件驱动方式代替顺序扫描,性能更高。 信号驱动I/O 需要开启套接口信号驱动I/O功能，系统通过调用sigaction执行一个信号处理函数（此系统调用立即返回，非阻塞）。当数据返回时生成一个SIGIO，通过信号回调通知应用系统调用recvfrom读取数据。 异步I/O 告知kernel启动某个操作，并让kernel在完成整个操作后（包括将数据从kernel复制到用户自己的缓存区）进行通知，与信号驱动模型的主要区别是信号驱动I/O有kernel通知何时开始，而异步I/O有kernel通知何时完成。 ####epoll epoll在2.5.44内核中被引进,epoll与select的原理比较相似，主要因为select一些固有的缺陷所有linux使用了epoll来代替select.而除了epoll，在freeBSD下还有kqueue,Solaris的/dev/poll.epoll 在文件描述符可进行 I/O 操作时进行通知，而 kqueue 和 IOCP 都在请求的操作完成时进行通知。 在select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。 ######epoll的优点 支持一个进程打开的socket描述符（fd）不受FD_SETSIZE限制(仅受限与操作系统的最大文件句柄数) I/O效率不会随着FD的数目的增加而线性下降 使用mmap加速内核与用户空间的消息传递（mmap是一种内存映射文件的方法，可以将一个文件或者其它对象映射到进程的虚拟地址空间，实现文件磁盘地址和进程虚拟地址空间中某一段地址的一一对映，这样应用程序就可以通过访问进程虚拟内存地地址直接访问到文件或对象。） epoll的api更加简单 来源netty netty权威指南","link":"/2019/04/18/year-month-day-LinuxIO-md/"}],"tags":[{"name":"spring security","slug":"spring-security","link":"/tags/spring-security/"},{"name":"icarus","slug":"icarus","link":"/tags/icarus/"},{"name":"linux","slug":"linux","link":"/tags/linux/"}],"categories":[]}